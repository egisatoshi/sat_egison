;; to comfirm an allocation

(define $variable
  (matcher {[<no-polar $> [nat] {[$tgt {tgt (neg tgt)}]}]
            [,$x [] {[$tgt (if (eq? tgt x) {[]} {})]}]
            [$ [something] {[$tgt {tgt}]}]}))

(define $eval-literal
  (lambda [$alc $lit]
    (member? lit alc)))

(define $eval-cls
  (lambda [$alc $cls]
    (match cls (list integer)
      {[<nil> #f]
       [<cons $lit $rst> (or (eval-literal alc lit) (eval-cls alc rst))]})))

(define $eval-cnf
  (lambda [$alc $cnf]
    (match cnf (list (list integer))
      {[<nil> #t]
       [<cons $cls $rst> (and (eval-cls alc cls) (eval-cnf alc rst))]})))

;; to solve sat problem

(define $answer
  (matcher {[<sat $> [(set nat)] {[<SAT $alc> {[alc]}] [<UNSAT> {}]}]
            [<unsat> [] {[<SAT $alc> {}] [<UNSAT> {[]}]}]
            [$ [something] {[$tgt {[tgt]}]}]}))

(define $mor
  (lambda [$x $y]
    (match x answer
      {[<sat _> x]
       [<unsat> y]})))

(define $allocate-help
  (lambda [$cnf $lit]
    (match-all cnf (set (set integer))
      [<cons (& $cls !<cons ,lit _>) _> (delete (neg lit) cls)])))

(define $allocate
  (lambda [$lit $cnf $vars $alc]
    [(allocate-help cnf lit) (delete (abs lit) vars) (cons lit alc)]))

(define $delete-tautology
  (lambda [$cnf]
    (match (map unique cnf) (list (multiset integer))
      {[<cons <cons $lit <cons ,(neg lit) _>> $tail> (delete-tautology tail)]
       [<cons $cls $tail> (cons cls (delete-tautology tail))]
       [<nil> {}]})))

(define $preprocess
  (lambda [$cnf]
    (delete-tautology cnf)))

(define $sat
  (letrec
    {[$sat-body
      (lambda [$cnf $vars $alc $lvl]
        (match [vars cnf] [(multiset variable) (multiset (multiset integer))]
          {[[_ <nil>] <SAT alc>]
           [[_ <cons <nil> _>] <UNSAT>]
           [[_ <cons <cons $lit <nil>> _>] (sat-body (allocate lit cnf vars alc) lvl)]
           [[<nil> _] "Error"]
           [[<cons <no-polar $lit> _> !<cons <cons ,lit _> _>]
            (sat-body (allocate (neg lit) cnf vars alc) lvl)]
           [[<cons $x _> _]
            (mor (sat-body (allocate x cnf vars alc) (+ 1 lvl))
                 (sat-body (allocate (neg x) cnf vars alc) (+ 1 lvl)))]}))]}
    (lambda [$num-of-var $cnf] (sat-body (preprocess cnf) (take num-of-var nats) {}) 0)))

; generater of random 3-cnf

(define $random-literal
  (lambda [$num-of-var]
    (let {[$var (pure-rand 1 num-of-var)]}
      (match (pure-rand 1 2) nat
        {[,1 var]
         [_  (neg var)]}))))

(define $random-3cnf
  (lambda [$num-of-var $num-of-cls]
    (match num-of-cls nat
      {[<o> {}]
       [<s $n> 
        (cons {(random-literal num-of-var)
               (random-literal num-of-var)
               (random-literal num-of-var)}
              (random-3cnf num-of-var n))]})))

(define $test-sat
  (lambda [$num-of-var $num-of-cls]
    (let* {[$cnf (random-3cnf num-of-var num-of-cls)]
           [$res (sat num-of-var cnf)]
           [$evl (match res answer
                   {[<sat $alc> (if (eval-cnf alc cnf) "OK" "NG")]
                    [<unsat> "cannot confirm"]})]}
    (do {(print "cnf:")
         (print (show cnf))
         (print "(sat cnf):")
         (print (show res))
         (print "confirmation:")
         (print evl)
         }
      (return)))))

;; parser originally written by Nishiwaki

(define $split-line
  (lambda [$line]
    (filter (lambda [$s] (not (eq? s ""))) (split-string " " line))))

(define $read-cnf
  (lambda [$fn]
    (io (do {[$port (open-input-file fn)]}
          (letrec {[$go (lambda [$num $acc]
                          (do {[$end? (eof-port? port)]}
                            (if end?
                              (return [num (reverse acc)])
                              (do {[$line (read-line-from-port port)]}
                                (if (eq? (S.car line) c#c) (go num acc)
                                  (if (eq? (S.car line) c#p) 
                                    (go (read (car (cdr (cdr (split-line line))))) acc)
                                    (go num (cons (rdc (map read (split-line line))) acc))))))))]}
            (go 0 {}))))))

(define $main
  (match-lambda (list string)
    {[<cons $fn _>
      (let* {[[$num $cnf] (read-cnf fn)]
             [$res (sat num cnf)]
             [$con (match res answer
                     {[<sat $alc> (if (eval-cnf alc cnf) "OK" "NG")]
                      [<unsat> "unsat"]})]}
        (do {(print (show res))
             (print con)}))]}))
