(define $x 5)

(define $my-multiset
  (lambda [$a]
    (matcher
      {[<nil> [] {[{} {[]}] [_ {}]}]
       [<cons $ $> [a (my-multiset a)]
        {[$tgt (match-all tgt (list a)
                 [<join $hs <cons $x $ts>> [x (append hs ts)]])]}]
       [,$val []
        {[$tgt (match [val tgt] [(list a) (my-multiset a)]
                {[[<nil> <nil>] {[]}]
                 [[<cons $x $xs> <cons ,x ,xs>] {[]}]
                 [[_ _] {}]})]}]
       [$ [something] {[$tgt {tgt}]}]})))

(define $mem?
  (lambda [$xs $x]
    (match xs (set something) {[<cons ,x _> #t] [_ #f]})))

(define $alc-ref
  (lambda [$alc $var]
    (if (mem? alc var) <T> <F>)))

(define $neg
  (lambda [$val]
    (match val something {[,<T> <F>] [,<F> <T>]})))

(define $literal
  (matcher {[<p $> [nat] {[<Pos $x> {x}] [_ {}]}]
            [<n $> [nat] {[<Neg $x> {x}] [_ {}]}]
            [,$l [] {[$tgt (if (eq? tgt l) {[]} {})]}]
            [$ [something] {[$tgt {tgt}]}]}))

(define $eval-literal
  (lambda [$alc $lit]
    (match lit literal {[<p $var> (alc-ref alc var)]
                        [<n $var> (neg (alc-ref alc var))]})))

(define $eval-cls
  (lambda [$alc $cls]
    (match cls (list something)
      {[<nil> <F>]
       [<cons $lit $rst> (match (eval-literal alc lit) something
                           {[,<T> <T>]
                            [,<F> (eval-cls alc rst)]})]})))

(define $eval-cnf
  (lambda [$alc $cnf]
    (match cnf (list something)
      {[<nil> <T>]
       [<cons $cls $rst> (match (eval-cls alc cls) something
                           {[,<T> (eval-cnf alc rst)]
                            [,<F> <F>]})]})))

;; (define $sat
;;   (lambda [$n $cnf] ; n is the number of variables in cnf
;;     (let {[$vars (between 1 n)]}
;;       (match-all vars (multiset integer)
;;         [<join (& $alc ?(lambda [$alc] (eq? (eval-cnf alc cnf) <T>))) _> alc]))))

(define $allocate-true
  (lambda [$cnf $var]
    (match-all cnf (set (set literal))
      [<cons (& $cls !<cons <p ,var> _>) _> (delete <Neg var> cls)])))

(define $allocate-false
  (lambda [$cnf $var]
    (match-all cnf (set (set literal))
      [<cons (& $cls !<cons <n ,var> _>) _> (delete <Pos var> cls)])))

(define $delete-literal
  (lambda [$lit $cnf $vars $alc]
    (match lit literal
      {[<p $x> [(allocate-true cnf x) (delete x vars) (cons x alc)]]
       [<n $x> [(allocate-false cnf x) (delete x vars) alc]]})))

(define $exist?
  (lambda [$lit $cnf]
    (match cnf (multiset (multiset literal))
      {[<cons <cons ,lit _> _> #t]
       [_ #f]})))

(define $answer
  (matcher {[<sat $> [(set Integer)] {[<SAT $alc> {[alc]}] [<UNSAT> {}]}]
            [<unsat> [] {[<SAT $alc> {}] [<UNSAT> {[]}]}]
            [$ [something] {[$tgt {[tgt]}]}]}))

(define $cons-answer
  (lambda [$x $res]
    (match res answer
      {[<sat $alc> <SAT (cons x alc)>]
       [<unsat> <UNSAT>]})))

(define $sat
  (lambda [$cnf $vars $alc]
    (match [vars cnf] [(multiset integer) (multiset (multiset literal))]
      {[[_ <nil>] <SAT alc>]
       [[_ <cons <nil> _>] <UNSAT>]
       [[_ <cons <cons $lit <nil>> _>] (sat (delete-literal lit cnf vars alc))]
       [[<nil> _] "Error"]
       [[<cons $x _> !<cons <cons ,<Pos x> _> _>]
        (sat (delete-literal <Neg x> cnf vars alc))]
       [[<cons $x _> !<cons <cons ,<Neg x> _> _>]
        (sat (delete-literal <Pos x> cnf vars alc))]
       [[<cons $x $xs> _]
        (match (sat (allocate-true cnf x) xs (cons x alc)) answer
          {[(& <sat _> $ans) ans]
           [<unsat> (sat (allocate-false cnf x) xs alc)]})]})))

(define $sample-cnf1
  {{<Pos 1> <Pos 2>} {<Pos 1> <Neg 2>} {<Neg 1> <Neg 2>}})
(define $sample-alc1-1
  {1 2})
(define $sample-alc1-2
  {1})
(define $sample-cnf2
  {{<Pos 1> <Pos 2>} {<Neg 1> <Pos 2>} {<Pos 1> <Neg 2>} {<Neg 1> <Neg 2>}})

(define $read-comment
  (lambda [$port]
    (do {[$c (read-char-from-port port)]
         (write "c: ")
         (write (show c))
         (write "\n")}
      (match c char
        {[,'c' (do {(read-line-from-port port)} (read-comment port))]
         [_ (return [])]}))))

;; (define $read-header
;;   (lambda [$port]
;;     (

(define $read-DIMACS
  (lambda [$port]
    (do {(read-comment port)
        [$n (read-header port)]
        [$cnf (read-body port)]}
      [n cnf])))

(define $main
  (lambda [$args]
    (do {[$inport (open-input-file "./input.txt")]
         (read-comment inport)
         [$c (read-line-from-port inport)]
         (write (show c))
         (close-input-port inport)}
      (return 0))))
