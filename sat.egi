;; to comfirm an allocation

(define $alc-ref
  (lambda [$alc $var]
    (if (member? var alc) <T> <F>)))

(define $val-neg
  (lambda [$val]
    (match val something {[,<T> <F>] [,<F> <T>]})))

(define $literal
  (matcher {[<p $> [nat] {[$x (if (lt? 0 x) {x} {})]}]
            [<n $> [nat] {[$x (if (lt? x 0) {(neg x)} {})]}]
            [,$l [] {[$tgt (if (eq? tgt l) {[]} {})]}]
            [$ [something] {[$tgt {tgt}]}]}))

(define $var-of-literal
  (lambda [$lit]
    (abs lit)))

(define $eval-literal
  (lambda [$alc $lit]
    (match lit literal {[<p $var> (alc-ref alc var)]
                        [<n $var> (val-neg (alc-ref alc var))]})))

(define $eval-cls
  (lambda [$alc $cls]
    (match cls (list literal)
      {[<nil> <F>]
       [<cons $lit $rst> (match (eval-literal alc lit) something
                           {[,<T> <T>]
                            [,<F> (eval-cls alc rst)]})]})))

(define $eval-cnf
  (lambda [$alc $cnf]
    (match cnf (list something)
      {[<nil> <T>]
       [<cons $cls $rst> (match (eval-cls alc cls) something
                           {[,<T> (eval-cnf alc rst)]
                            [,<F> <F>]})]})))

;; to solve sat problem

(define $allocate
  (lambda [$cnf $lit]
    (match-all cnf (set (set literal))
      [<cons (& $cls !<cons ,lit _>) _> (delete (neg lit) cls)])))

(define $delete-literal
  (lambda [$lit $cnf $vars $alc]
    (match lit literal
      {[<p $x> [(allocate cnf x) (delete x vars) (cons x alc)]]
       [<n $x> [(allocate cnf (neg x)) (delete x vars) alc]]})))

(define $answer
  (matcher {[<sat $> [(set nat)] {[<SAT $alc> {[alc]}] [<UNSAT> {}]}]
            [<unsat> [] {[<SAT $alc> {}] [<UNSAT> {[]}]}]
            [$ [something] {[$tgt {[tgt]}]}]}))

(define $enumerate-vars
  (lambda [$cnf]
    (unique (match-all cnf (multiset (multiset literal))
      [<cons <cons $lit _> _> (var-of-literal lit)]))))

(define $delete-tautology
  (lambda [$cnf]
    (match cnf (list (multiset literal))
      {[<cons <cons $lit <cons ,lit $cls>> $tail>
        (delete-tautology (cons (cons lit cls) tail))]
       [<cons <cons $lit <cons ,(flip-literal lit) _>> $tail>
              (delete-tautology tail)]
       [<cons $cls $tail> (cons cls (delete-tautology tail))]
       [<nil> {}]})))

(define $preprocess
  (lambda [$cnf]
    (delete-tautology cnf)))

(define $sat
  (letrec
    {[$sat-body
      (lambda [$cnf $vars $alc]
        (match [vars cnf] [(multiset integer) (multiset (multiset literal))]
          {[[_ <nil>] <SAT alc>]
           [[_ <cons <nil> _>] <UNSAT>]
           [[_ <cons <cons $lit <nil>> _>] (sat-body (delete-literal lit cnf vars alc))]
           [[<nil> _] "Error"]
           [[<cons $x _> !<cons <cons ,x _> _>]
            (sat-body (delete-literal (neg x) cnf vars alc))]
           [[<cons $x _> !<cons <cons ,(neg x) _> _>]
            (sat-body (delete-literal x cnf vars alc))]
           [[<cons $x $xs> _]
            (match (sat-body (allocate cnf x) xs (cons x alc)) answer
              {[(& <sat _> $ans) ans]
               [<unsat> (sat-body (allocate cnf (neg x)) xs alc)]})]}))]}
    (lambda [$cnf] (sat-body (preprocess cnf) (enumerate-vars cnf) {}))))

;; sample inputs
;; A comment shows a possible allocation

(define $random-literal
  (lambda [$num-of-var]
    (let {[$var (pure-rand 1 num-of-var)]}
      (match (pure-rand 1 2) nat
        {[,1 var]
         [_  (neg var)]}))))

(define $random-3cnf
  (lambda [$num-of-var $num-of-cls]
    (match num-of-cls nat
      {[<o> {}]
       [<s $n> 
        (cons {(random-literal num-of-var)
               (random-literal num-of-var)
               (random-literal num-of-var)}
              (random-3cnf num-of-var n))]})))

(define $test-sat
  (lambda [$num-of-var $num-of-cls]
    (let* {[$cnf (random-3cnf num-of-var num-of-cls)]
           [$res (sat cnf)]
           [$evl (match res answer
                   {[<sat $alc> (match (eval-cnf alc cnf) something
                                  {[,<T> "OK"]
                                   [,<N> "NG"]})]
                    [<unsat> "cannot confirm"]})]}
    (do {(print "cnf:")
         (print (show cnf))
         (print "(sat cnf):")
         (print (show res))
         (print "confirmation:")
         (print evl)
         }
      (return)))))

;; parser written by Nishiwaki

(define $read-cnf
  (lambda [$fn]
    (io (do {[$port (open-input-file fn)]}
          (letrec {[$go (lambda [$acc]
                          (do {[$end? (eof-port? port)]}
                            (if end?
                              (return (reverse acc))
                              (do {[$line (read-line-from-port port)]}
                                (if (or (eq? (S.car line) c#c)
                                        (eq? (S.car line) c#p))
                                  (go acc)
                                  (go (cons (rdc (map read (filter (lambda [$s] (not (eq? s ""))) (split-string " " line)))) acc)))))))]}
            (go {}))))))

(define $main
  (match-lambda (list string)
    {[<cons $fn _>
      (let* {[$cnf (read-cnf fn)]
             [$res (sat cnf)]
             [$con (match res answer
                     {[<sat $alc> (match (eval-cnf alc cnf) something
                                    {[,<T> "OK"]
                                     [,<F> "NG"]})]
                      [<unsat> "unsat"]})]}
        (do {(print (show res))
             (print con)}))]}))
