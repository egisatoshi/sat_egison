;; to comfirm an allocation

(define $variable
  (matcher {[<no-polar $> [nat] {[$tgt {tgt (neg tgt)}]}]
            [,$x [] {[$tgt (if (eq? tgt x) {[]} {})]}]
            [$ [something] {[$tgt {tgt}]}]}))

(define $eval-literal
  (lambda [$alc $lit]
    (member? lit alc)))

(define $eval-cls
  (lambda [$alc $cls]
    (match cls (list integer)
      {[<nil> #f]
       [<cons $lit $rst> (or (eval-literal alc lit) (eval-cls alc rst))]})))

(define $eval-cnf
  (lambda [$alc $cnf]
    (match cnf (list (list integer))
      {[<nil> #t]
       [<cons $cls $rst> (and (eval-cls alc cls) (eval-cnf alc rst))]})))

;; to solve sat problem

(define $answer
  (matcher {[<sat $> [(set nat)] {[<SAT $alc> {[alc]}] [<UNSAT $w> {}]}]
            [<unsat $ $> [(multiset alclit) integer] {[<SAT $alc> {}] [<UNSAT $w $hL2> {[w hL2]}]}]
            [$ [something] {[$tgt {[tgt]}]}]}))

(define $mor
  (lambda [$x $y]
    (match x answer
      {[<sat _> x]
       [<unsat _> y]})))

(define $allocate-cls
  (lambda [$cls $lit $w $lvl]
    (match cls (list alclit)
      {[<cons <yet ,lit> $tail> (cons <Ald lit #t w lvl> (allocate-cls tail lit w lvl))]
       [<cons <yet ,(neg lit)> $tail> (cons <Ald (neg lit) #f w lvl> (allocate-cls tail lit w lvl))]
       [<cons $cls $tail> (cons cls (allocate-cls tail lit w lvl))]
       [<nil> {}]})))

(define $allocate-help
  (lambda [$cnf $lit $w $lvl]
    (map (allocate-cls $ lit w lvl) cnf)))

(define $allocate
  (lambda [$lit $cnf $vars $alc $w $lvl]
    [(allocate-help cnf lit w lvl) (delete (abs lit) vars) (cons lit alc) lvl]))

(define $delete-tautology
  (lambda [$cnf]
    (match (map unique cnf) (list (multiset integer))
      {[<cons <cons $lit <cons ,(neg lit) _>> $tail> (delete-tautology tail)]
       [<cons $cls $tail> (cons cls (delete-tautology tail))]
       [<nil> {}]})))

(define $preprocess
  (lambda [$cnf]
    (map (map alclit-of-lit $) (delete-tautology cnf))))

(define $alclit
  (matcher
    {[<yet $> [integer] {[<Yet $lit> {lit}] [<Ald $lit $v $w $lvl> {}]}]
     [<ald $ $ $ $> [integer bool clause integer] {[<Ald $lit $v $w $lvl> {[lit v w lvl]}] [<Yet $lit> {}]}]
     [$ [eq] {[$tgt {tgt}]}]}))

(define $alclit-of-lit
  (lambda [$lit]
    <Yet lit>))

(define $lit-of-alclit
  (match-lambda alclit {[<yet $lit> lit] [<ald $lit _ _ _> lit]}))

(define $v-of-ald
  (match-lambda alclit {[<ald _ $v _ _> v]}))

(define $w-of-ald
  (match-lambda alclit {[<ald _ _ $w _> w]}))

(define $highest-lvl
  (match-lambda (list alclit)
    {[<nil> [<Ald 0 #f #f -1> <Ald 0 #f #f -2>]]
     [<cons <yet _> $tail> (highest-lvl tail)]
     [<cons $alit $tail> 
      (let* {[$lvl (lvl-of-ald alit)]
             [[$al1 $al2] (highest-lvl tail)]
             [$fst (lvl-of-ald al1)]
             [$snd (lvl-of-ald al2)]}
        (if (lt? lvl snd) [al1 al2] (if (lt? lvl fst) [al1 alit] [alit al1])))]}))
          
(define $deduce
  (lambda [$cls1 $cls2]
    (match [cls1 cls2] [clause clause]
      {[[<lcons $lit $tail1> <lcons ,lit $tail2>] (deduce cls1 tail2)]
       [[<lcons $lit $tail1> <lcons ,(neg lit) $tail2>] (deduce tail1 tail2)]
       [[_ _] (append cls1 cls2)]})))

(define $learn
  (lambda [$w]
    (let* {[[$fst $snd] (highest-lvl w)]
           [[$hl1 $hl2] [(lvl-of-ald fst) (lvl-of-ald snd)]]}
      (if (lt? hl1 0) (io (print "Error: learn: There is no allocated literal."))
        (if (lt? hl2 hl1) [w hl2]
          (match (w-of-ald snd) clause
            {[,#f (match (w-of-ald fst) clause
                    {[,#f (io (print "Error: learn: There are two variable decided in the same level."))]
                     [$w1 (learn (deduce w1 w))]})]
             [$w2 (learn (deduce w w2))]}))))))

(define $lvl-of-ald
  (match-lambda alclit {[<ald _ _ _ $lvl> lvl]}))

(define $allocated?
  (match-lambda alclit {[<yet _> #f] [<ald _ _ _ _> #t]}))

(define $clause
  (matcher
    {[<nil> [] {[$tgt (match tgt (multiset alclit)
                        {[<cons <ald _ ,#t _ _> _> {}] [<cons <yet _> _> {}] [_ {[]}]})]}]
     [<cons $ $> [integer clause] {[$tgt (match-all tgt (multiset alclit)
                                           [<cons <yet $var> $tail> [var tail]])]}]
     [<lcons $ $> [integer clause] {[$tgt (match-all tgt (multiset alclit)
                                            [<cons (| <yet $lit> <ald $lit _ _ _>) $tail> [lit tail]])]}]
     [<mcons $ $> [alclit clause] {[$tgt (match-all tgt (multiset alclit) [<cons $x $y> [x y]])]}]
     [<satisfied> [] {[$tgt (match tgt (multiset alclit)
                              {[<cons <ald _ ,#t _ _> _> {[]}] [_ {}]})]}]
     [$ [eq] {[$tgt {[tgt]}]}]
     }))
    
(define $formula
  (matcher
    {[<nil> [] {[$tgt (match tgt (multiset clause) {[!<cons !<satisfied> _> {[]}] [_ {}]})]}]
     [<cons $ $> [clause formula] {[$tgt (match-all tgt (multiset clause) [<cons (& $cls !<satisfied>) $tail> [cls tail]])]}]
     [$ [eq] {[$tgt {[tgt]}]}]
     }))

(define $back-jump-cls
  (lambda [$cls $vars $alc $lvl]
    (match cls (list alclit)
      {[<nil> [{} vars alc lvl]]
       [<cons (& $alclit (| <yet _> <ald _ _ _ ?(lt? $ lvl)>)) $tail>
        (let {[[$cls1 $vars1 $alc1 $lvl1] (back-jump-cls tail vars alc lvl)]} [(cons alclit cls1) vars alc1 lvl1])]
       [<cons <ald $lit _ _ _> $tail>
        (let {[[$cls1 $vars1 $alc1 $lvl1] (back-jump-cls tail vars alc lvl)]
              [$var (abs lit)]}
          [(cons <Yet lit> cls1)
           (if (member? var vars1) vars1 (cons (var vars1)))
           (match-all alc1 (multiset integer) [<cons (& $x !(| ,var ,(neg ver))) _> x])
           lvl])]})))

(define $back-jump
  (lambda [$cnf $vars $alc $lvl]
    (match cnf (list clause)
      {[<nil> [cnf vars alc lvl]]
       [<cons $cls $tail> 
        (back-jump-cls cls vars alc lvl)]})))
  
(define $sat
  (letrec
    {[$sat-body
      (lambda [$cnf $vars $alc $lvl]
        (match [vars cnf] [(multiset variable) formula]
          {[[_ <nil>] <SAT alc>]
           [[_ <cons (& $w <nil>) _>] <UNSAT (learn w)>]
           [[_ <cons (& $w <cons $lit <nil>>) _>] (sat-body (allocate lit cnf vars alc w lvl))]
           [[<nil> _] (io (print "Error: sat: no variables"))]
           [[<cons $x _> _] (branch x cnf vars alc (+ 1 lvl))]}))]
     [$branch
      (lambda [$var $cnf $vars $alc $lvl]
        (match (sat-body (allocate var cnf  vars alc #f lvl)) answer
          {[(& $acc <sat _>) acc]
           [<unsat [$w ?(lt? $ 0)]> (sat-body (back-jump (cat w cnf) vars alc 0))]
           [<unsat [$w $hl2]> (sat-body (back-jump (cat w cnf) vars alc hl2))]}))]}
    (lambda [$num-of-var $cnf] (sat-body (preprocess cnf) (take num-of-var nats) {} 0))))

; generater of random 3-cnf

(define $random-literal
  (lambda [$num-of-var]
    (let {[$var (pure-rand 1 num-of-var)]}
      (match (pure-rand 1 2) nat
        {[,1 var]
         [_  (neg var)]}))))

(define $random-3cnf
  (lambda [$num-of-var $num-of-cls]
    (match num-of-cls nat
      {[<o> {}]
       [<s $n> 
        (cons {(random-literal num-of-var)
               (random-literal num-of-var)
               (random-literal num-of-var)}
              (random-3cnf num-of-var n))]})))

(define $test-sat
  (lambda [$num-of-var $num-of-cls]
    (let* {[$cnf (random-3cnf num-of-var num-of-cls)]
           [$res (sat num-of-var cnf)]
           [$evl (match res answer
                   {[<sat $alc> (if (eval-cnf alc cnf) "OK" "NG")]
                    [<unsat _> "cannot confirm"]})]}
    (do {(print "cnf:")
         (print (show cnf))
         (print "(sat cnf):")
         (print (show res))
         (print "confirmation:")
         (print evl)
         }
      (return)))))

;; parser originally written by Nishiwaki

(define $split-line
  (lambda [$line]
    (filter (lambda [$s] (not (eq? s ""))) (split-string " " line))))

(define $read-cnf
  (lambda [$fn]
    (io (do {[$port (open-input-file fn)]}
          (letrec {[$go (lambda [$num $acc]
                          (do {[$end? (eof-port? port)]}
                            (if end?
                              (return [num (reverse acc)])
                              (do {[$line (read-line-from-port port)]}
                                (if (eq? (S.car line) c#c) (go num acc)
                                  (if (eq? (S.car line) c#p) 
                                    (go (read (car (cdr (cdr (split-line line))))) acc)
                                    (go num (cons (rdc (map read (split-line line))) acc))))))))]}
            (go 0 {}))))))

(define $main
  (match-lambda (list string)
    {[<cons $fn _>
      (let* {[[$num $cnf] (read-cnf fn)]
             [$res (sat num cnf)]
             [$con (match res answer
                     {[<sat $alc> (if (eval-cnf alc cnf) "OK" "NG")]
                      [<unsat> "unsat"]})]}
        (do {(print (show res))
             (print con)}))]}))
